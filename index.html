<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Mini Golf Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #87CEEB, #98FB98);
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 16px;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 24px;
            border-radius: 10px;
            text-align: center;
            font-size: 14px;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        #cameraControls {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        #powerMeter {
            position: absolute;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            width: 25px;
            height: 200px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 12px;
            z-index: 100;
            display: none;
            border: 2px solid white;
        }
        
        #powerFill {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            background: linear-gradient(to top, #ff4444, #ffff44, #44ff44);
            border-radius: 8px;
            transition: height 0.1s ease;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        #gameComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 18px;
            z-index: 200;
            display: none;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 15px;
            transition: background 0.3s ease;
        }
        
        button:hover {
            background: #45a049;
        }
        
        #aimIndicator {
            position: absolute;
            pointer-events: none;
            z-index: 50;
            display: none;
        }
        
        .aim-line {
            background: rgba(255, 255, 0, 0.8);
            height: 3px;
            border-radius: 2px;
            box-shadow: 0 0 6px rgba(255, 255, 0, 0.6);
        }
        
        .dotted-aim-line {
            background: linear-gradient(to right, transparent 0%, transparent 40%, rgba(255, 255, 255, 0.9) 40%, rgba(255, 255, 255, 0.9) 60%, transparent 60%, transparent 100%);
            background-size: 10px 100%;
            height: 2px;
            border-radius: 1px;
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.5);
        }

        /* Authentication styles */
        #authPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 16px;
            z-index: 300;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
            min-width: 300px;
        }
        
        #authPanel input {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            box-sizing: border-box;
        }
        
        #authPanel input:focus {
            outline: 2px solid #4CAF50;
        }
        
        #userInfo {
            position: absolute;
            top: 120px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        #leaderboard {
            position: absolute;
            top: 20px;
            right: 240px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            max-width: 200px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        button.secondary {
            background: #666;
        }
        
        button.secondary:hover {
            background: #555;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .error-message {
            color: #ff6b6b;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .success-message {
            color: #4CAF50;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        
        .leaderboard-entry.current-user {
            background: rgba(76, 175, 80, 0.2);
            padding: 5px;
            border-radius: 4px;
            border-bottom: 1px solid rgba(76, 175, 80, 0.4);
        }
    </style>
</head>
<body>
    <!-- Authentication Panel -->
    <div id="authPanel">
        <h2>üèåÔ∏è Mini Golf Championship</h2>
        <div id="authContent">
            <div id="loginForm">
                <h3>Sign In</h3>
                <input type="email" id="loginEmail" placeholder="Email" required>
                <input type="password" id="loginPassword" placeholder="Password" required>
                <button onclick="signIn()">Sign In</button>
                <p>Don't have an account? <a href="#" onclick="showSignUp()" style="color: #4CAF50;">Sign Up</a></p>
            </div>
            
            <div id="signupForm" style="display: none;">
                <h3>Create Account</h3>
                <input type="text" id="signupName" placeholder="Player Name" required>
                <input type="email" id="signupEmail" placeholder="Email" required>
                <input type="password" id="signupPassword" placeholder="Password (min 6 chars)" required>
                <button onclick="signUp()">Create Account</button>
                <p>Already have an account? <a href="#" onclick="showLogin()" style="color: #4CAF50;">Sign In</a></p>
            </div>
            
            <div id="guestOption">
                <hr style="margin: 20px 0; border-color: #666;">
                <button class="secondary" onclick="playAsGuest()">Play as Guest</button>
                <p style="font-size: 12px; color: #ccc;">Guest progress won't be saved</p>
            </div>
        </div>
        
        <div id="authMessages"></div>
    </div>

    <div id="ui">
        <div><strong>Hole:</strong> <span id="holeNumber">1</span> / 3</div>
        <div><strong>Par:</strong> <span id="par">3</span></div>
        <div><strong>Strokes:</strong> <span id="strokes">0</span></div>
        <div><strong>Total Score:</strong> <span id="totalScore">0</span></div>
        <div><strong>Best Score:</strong> <span id="bestScore">--</span></div>
    </div>
    
    <div id="userInfo" style="display: none;">
        <div><strong>Player:</strong> <span id="playerName">Guest</span></div>
        <div style="margin-top: 5px;">
            <button onclick="signOut()" style="padding: 4px 8px; font-size: 12px;">Sign Out</button>
        </div>
    </div>
    
    <div id="leaderboard" style="display: none;">
        <div style="font-weight: bold; margin-bottom: 10px; text-align: center;">üèÜ Leaderboard</div>
        <div id="leaderboardContent">Loading...</div>
    </div>
    
    <div id="controls">
        üéØ Click the BALL to aim & shoot ‚Ä¢ üîã Drag + SPACE for power ‚Ä¢ ‚å®Ô∏è Arrow keys for camera
    </div>
    
    <div id="cameraControls">
        <div style="margin-bottom: 5px;">Camera Help:</div>
        <div style="font-size: 11px;">
            ‚Üê ‚Üí : Rotate Left/Right<br>
            ‚Üë ‚Üì : Angle Up/Down<br>
            + - : Zoom In/Out
        </div>
    </div>
    
    <div id="powerMeter">
        <div id="powerFill"></div>
    </div>
    
    <div id="aimIndicator"></div>
    <div id="precisionAimIndicator"></div>
    
    <div id="gameComplete">
        <h2>üèÜ Game Complete!</h2>
        <p>Final Score: <span id="finalScore">0</span> strokes</p>
        <div id="scoreComparison"></div>
        <button onclick="restartGame()">Play Again</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Authentication and database variables
        const SUPABASE_URL = 'https://jjraqvrbwosiispqwwbg.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpqcmFxdnJid29zaWlzcHF3d2JnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgyNjUyODUsImV4cCI6MjA3Mzg0MTI4NX0.pg-U_TgO44XRMSFdC7JmR3oduP1dtcoj7aRlNqWKnlk';
        
        let supabase = null;
        let currentUser = null;
        let isGuest = false;
        const DEMO_MODE = true; // Set to false when you have Supabase credentials

        // Demo leaderboard data
        let demoLeaderboard = [
            { player_name: 'Alice', best_score: 15 },
            { player_name: 'Bob', best_score: 18 },
            { player_name: 'Carol', best_score: 22 },
            { player_name: 'Demo Player', best_score: 20 }
        ];

        // Initialize Supabase
        if (!DEMO_MODE && SUPABASE_URL !== 'YOUR_SUPABASE_URL_HERE') {
            try {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            } catch (error) {
                console.error('Failed to initialize Supabase:', error);
            }
        }

        // Authentication functions
        async function signUp() {
            const name = document.getElementById('signupName').value;
            const email = document.getElementById('signupEmail').value;
            const password = document.getElementById('signupPassword').value;
            
            if (!name || !email || !password) {
                showAuthMessage('Please fill in all fields', 'error');
                return;
            }
            
            if (password.length < 6) {
                showAuthMessage('Password must be at least 6 characters', 'error');
                return;
            }

            if (DEMO_MODE || !supabase) {
                currentUser = { email, user_metadata: { player_name: name } };
                isGuest = false;
                showAuthMessage('Demo account created!', 'success');
                setTimeout(startGame, 1500);
                return;
            }

            try {
                const { data, error } = await supabase.auth.signUp({
                    email: email,
                    password: password,
                    options: {
                        data: {
                            player_name: name
                        }
                    }
                });

                if (error) throw error;

                if (data.user && !data.user.email_confirmed_at) {
                    showAuthMessage('Please check your email to confirm your account', 'success');
                } else {
                    currentUser = data.user;
                    isGuest = false;
                    showAuthMessage('Account created successfully!', 'success');
                    setTimeout(startGame, 1500);
                }
            } catch (error) {
                showAuthMessage(error.message, 'error');
            }
        }

        async function signIn() {
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            
            if (!email || !password) {
                showAuthMessage('Please enter email and password', 'error');
                return;
            }

            if (DEMO_MODE || !supabase) {
                currentUser = { email, user_metadata: { player_name: email.split('@')[0] } };
                isGuest = false;
                showAuthMessage('Demo login successful!', 'success');
                setTimeout(startGame, 1000);
                return;
            }

            try {
                const { data, error } = await supabase.auth.signInWithPassword({
                    email: email,
                    password: password,
                });

                if (error) throw error;

                currentUser = data.user;
                isGuest = false;
                showAuthMessage('Signed in successfully!', 'success');
                setTimeout(startGame, 1000);
            } catch (error) {
                showAuthMessage(error.message, 'error');
            }
        }

        async function signOut() {
            if (DEMO_MODE || !supabase) {
                currentUser = null;
                isGuest = false;
                showAuthScreen();
                return;
            }

            try {
                const { error } = await supabase.auth.signOut();
                if (error) throw error;
                
                currentUser = null;
                isGuest = false;
                showAuthScreen();
            } catch (error) {
                console.error('Error signing out:', error);
            }
        }

        function playAsGuest() {
            currentUser = null;
            isGuest = true;
            startGame();
        }

        function showLogin() {
            document.getElementById('loginForm').style.display = 'block';
            document.getElementById('signupForm').style.display = 'none';
        }

        function showSignUp() {
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('signupForm').style.display = 'block';
        }

        function showAuthMessage(message, type) {
            const messagesDiv = document.getElementById('authMessages');
            messagesDiv.innerHTML = `<div class="${type}-message">${message}</div>`;
            setTimeout(() => {
                messagesDiv.innerHTML = '';
            }, 5000);
        }

        function showAuthScreen() {
            document.getElementById('authPanel').style.display = 'block';
            document.getElementById('userInfo').style.display = 'none';
            document.getElementById('leaderboard').style.display = 'none';
        }

        function startGame() {
            document.getElementById('authPanel').style.display = 'none';
            document.getElementById('userInfo').style.display = 'block';
            document.getElementById('leaderboard').style.display = 'block';
            
            const playerName = isGuest ? 'Guest' : 
                (currentUser?.user_metadata?.player_name || currentUser?.email?.split('@')[0] || 'Player');
            document.getElementById('playerName').textContent = playerName;
            
            loadBestScore();
            loadLeaderboard();
            
            if (!window.game) {
                window.game = new MiniGolfGame();
                window.game.init();
            }
        }

        // Database functions
        async function saveBestScore(score) {
            if (isGuest) return;

            if (DEMO_MODE || !supabase) {
                console.log('Demo mode: would save score', score);
                
                // Update demo leaderboard
                const playerName = currentUser?.user_metadata?.player_name || currentUser?.email?.split('@')[0];
                const existingIndex = demoLeaderboard.findIndex(entry => entry.player_name === playerName);
                
                if (existingIndex !== -1) {
                    if (score < demoLeaderboard[existingIndex].best_score) {
                        demoLeaderboard[existingIndex].best_score = score;
                    }
                } else {
                    demoLeaderboard.push({ player_name: playerName, best_score: score });
                }
                
                demoLeaderboard.sort((a, b) => a.best_score - b.best_score);
                return;
            }

            try {
                const playerName = currentUser.user_metadata?.player_name || currentUser.email.split('@')[0];
                
                const { data, error } = await supabase
                    .from('player_scores')
                    .upsert({
                        user_id: currentUser.id,
                        player_name: playerName,
                        best_score: score
                    });

                if (error) throw error;
                console.log('Score saved successfully');
            } catch (error) {
                console.error('Error saving score:', error);
            }
        }

        async function loadBestScore() {
            if (isGuest) {
                document.getElementById('bestScore').textContent = '--';
                return;
            }

            if (DEMO_MODE || !supabase) {
                const playerName = currentUser?.user_metadata?.player_name || currentUser?.email?.split('@')[0];
                const playerData = demoLeaderboard.find(entry => entry.player_name === playerName);
                document.getElementById('bestScore').textContent = playerData ? playerData.best_score : '--';
                return;
            }

            try {
                const { data, error } = await supabase
                    .from('player_scores')
                    .select('best_score')
                    .eq('user_id', currentUser.id)
                    .single();

                if (error && error.code !== 'PGRST116') throw error;

                document.getElementById('bestScore').textContent = data?.best_score || '--';
            } catch (error) {
                console.error('Error loading best score:', error);
                document.getElementById('bestScore').textContent = '--';
            }
        }

        async function loadLeaderboard() {
            if (DEMO_MODE || !supabase) {
                displayLeaderboard(demoLeaderboard);
                return;
            }

            try {
                const { data, error } = await supabase
                    .from('player_scores')
                    .select('player_name, best_score')
                    .order('best_score', { ascending: true })
                    .limit(10);

                if (error) throw error;

                displayLeaderboard(data || []);
            } catch (error) {
                console.error('Error loading leaderboard:', error);
                document.getElementById('leaderboardContent').textContent = 'Error loading leaderboard';
            }
        }

        function displayLeaderboard(scores) {
            const content = document.getElementById('leaderboardContent');
            
            if (scores.length === 0) {
                content.innerHTML = '<div style="text-align: center; color: #ccc;">No scores yet</div>';
                return;
            }

            const currentPlayerName = isGuest ? null : 
                (currentUser?.user_metadata?.player_name || currentUser?.email?.split('@')[0]);

            content.innerHTML = scores.map((score, index) => {
                const isCurrentUser = currentPlayerName && score.player_name === currentPlayerName;
                return `
                    <div class="leaderboard-entry ${isCurrentUser ? 'current-user' : ''}">
                        <span>${index + 1}. ${score.player_name}</span>
                        <span>${score.best_score}</span>
                    </div>
                `;
            }).join('');
        }

        // Initialize auth state
        if (!DEMO_MODE && supabase) {
            supabase.auth.onAuthStateChange((event, session) => {
                if (session) {
                    currentUser = session.user;
                    isGuest = false;
                    startGame();
                } else {
                    showAuthScreen();
                }
            });
        }

        // Your original MiniGolfGame class - unchanged
        class MiniGolfGame {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.ball = null;
                this.currentHole = 1;
                this.totalHoles = 3;
                this.strokes = 0;
                this.totalScore = 0;
                this.isAiming = false;
                this.isChargingPower = false;
                this.power = 0;
                this.maxPower = 1.0;
                this.powerChargeSpeed = 1.5;
                this.aimStart = new THREE.Vector2();
                this.aimCurrent = new THREE.Vector2();
                this.aimLine = null;
                this.ballVelocity = new THREE.Vector3();
                this.isMoving = false;
                this.queuedShot = null;
                this.pressedKeys = new Set();
                this.obstacleBoxes = [];
                this.boundaries = [];
                this.cameraControls = {
                    isMouseDown: false,
                    isRightClick: false,
                    previousMousePosition: { x: 0, y: 0 },
                    phi: Math.PI / 5, // Fixed angle - more professional view
                    theta: 0,
                    radius: 20,
                    target: new THREE.Vector3(0, 0, 0),
                    minRadius: 10,
                    maxRadius: 30,
                    autoRotateSpeed: 0.2, // Slow auto-rotation around ball
                    smoothing: 0.1
                };
                this.courses = this.createCourses();
            }

            init() {
                this.setupRenderer();
                this.setupScene();
                this.setupCamera();
                this.setupLighting();
                this.loadHole(this.currentHole);
                this.setupEventListeners();
                this.updateUI();
                this.animate();
            }

            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
            }

            setupCamera() {
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.updateCameraPosition();
            }

            updateCameraPosition() {
                const target = this.ball ? this.ball.position.clone() : new THREE.Vector3(0, 0, 0);
                target.y = 0;
                this.cameraControls.target.copy(target);
                
                const x = this.cameraControls.radius * Math.sin(this.cameraControls.phi) * Math.cos(this.cameraControls.theta);
                const y = this.cameraControls.radius * Math.cos(this.cameraControls.phi);
                const z = this.cameraControls.radius * Math.sin(this.cameraControls.phi) * Math.sin(this.cameraControls.theta);
                
                this.camera.position.set(
                    target.x + x,
                    Math.max(target.y + y, 2),
                    target.z + z
                );
                this.camera.lookAt(target);
            }

            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(30, 40, 20);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 1;
                directionalLight.shadow.camera.far = 100;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.bottom = -50;
                directionalLight.shadow.camera.top = 50;
                this.scene.add(directionalLight);
            }

            createCourses() {
                return {
                    1: {
                        par: 3,
                        startPos: new THREE.Vector3(0, 1.2, 12),
                        holePos: new THREE.Vector3(0, 0.5, -12),
                        obstacles: [],
                        hasSlope: false
                    },
                    2: {
                        par: 4,
                        startPos: new THREE.Vector3(0, 1.2, 12),
                        holePos: new THREE.Vector3(0, 0.5, -12),
                        obstacles: [
                            { type: 'wall', pos: [-2, 1.5, 4], size: [0.5, 2, 3] },
                            { type: 'wall', pos: [2, 1.5, -2], size: [0.5, 2, 3] },
                            { type: 'block', pos: [0, 1.2, 0], size: [1.5, 1.5, 1.5] }
                        ],
                        hasSlope: false
                    },
                    3: {
                        par: 5,
                        startPos: new THREE.Vector3(0, 2.5, 12), // Higher start for slope
                        holePos: new THREE.Vector3(0, 0.5, -12),
                        obstacles: [
                            { type: 'wall', pos: [-2, 1.5, 2], size: [0.5, 2, 2] },
                            { type: 'wall', pos: [2, 1.5, -6], size: [0.5, 2, 2] }
                        ],
                        hasSlope: true
                    }
                };
            }

            loadHole(holeNumber) {
                const objectsToRemove = [];
                this.scene.traverse((child) => {
                    if (child.userData.courseElement) {
                        objectsToRemove.push(child);
                    }
                });
                objectsToRemove.forEach(obj => this.scene.remove(obj));
                
                this.boundaries = [];
                this.obstacleBoxes = [];

                const course = this.courses[holeNumber];
                
                this.createTerrain();
                this.createHole(course.holePos);
                this.createObstacles(course.obstacles);
                this.createTrees();
                this.createBoundaries();
                
                if (this.ball) {
                    this.scene.remove(this.ball);
                }
                if (this.ballRing) {
                    this.scene.remove(this.ballRing);
                }
                this.createBall(course.startPos);
                
                this.updateCameraPosition();
            }

            createTerrain() {
                const geometry = new THREE.PlaneGeometry(80, 80, 32, 32);
                const material = new THREE.MeshLambertMaterial({ color: 0x7FFF00 });
                const terrain = new THREE.Mesh(geometry, material);
                terrain.rotation.x = -Math.PI / 2;
                terrain.receiveShadow = true;
                terrain.userData.courseElement = true;
                this.scene.add(terrain);

                this.createRaisedTrack();
                this.createStripes();
            }

            createRaisedTrack() {
                const course = this.courses[this.currentHole];
                
                if (course.hasSlope) {
                    // Create sloped platform for level 3
                    this.createSlopedTrack();
                } else {
                    // Standard flat platform for levels 1 and 2
                    const platformGeom = new THREE.BoxGeometry(10, 0.5, 28);
                    const platformMat = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
                    const platform = new THREE.Mesh(platformGeom, platformMat);
                    platform.position.set(0, 0.25, 0);
                    platform.userData.courseElement = true;
                    this.scene.add(platform);
                }

                // Create borders (same for all levels)
                const borderMat = new THREE.MeshLambertMaterial({ color: 0xFF4500 });
                
                const leftBorder = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2, 28), borderMat);
                leftBorder.position.set(-5.25, 1, 0);
                leftBorder.userData.courseElement = true;
                leftBorder.userData.isBoundary = true;
                this.scene.add(leftBorder);
                
                const rightBorder = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2, 28), borderMat);
                rightBorder.position.set(5.25, 1, 0);
                rightBorder.userData.courseElement = true;
                rightBorder.userData.isBoundary = true;
                this.scene.add(rightBorder);

                const backWall = new THREE.Mesh(new THREE.BoxGeometry(10, 2, 0.5), borderMat);
                backWall.position.set(0, 1, -14.25);
                backWall.userData.courseElement = true;
                backWall.userData.isBoundary = true;
                this.scene.add(backWall);

                const frontWall = new THREE.Mesh(new THREE.BoxGeometry(10, 2, 0.5), borderMat);
                frontWall.position.set(0, 1, 14.25);
                frontWall.userData.courseElement = true;
                frontWall.userData.isBoundary = true;
                this.scene.add(frontWall);

                this.boundaries = [
                    { type: 'vertical', x: -5.25, minZ: -14, maxZ: 14 },
                    { type: 'vertical', x: 5.25, minZ: -14, maxZ: 14 },
                    { type: 'horizontal', z: -14.25, minX: -5, maxX: 5 },
                    { type: 'horizontal', z: 14.25, minX: -5, maxX: 5 }
                ];

                // Add ramps
                const rampMat = new THREE.MeshLambertMaterial({ color: 0xDAA520 });
                
                const startRampGeom = new THREE.BoxGeometry(10, 0.2, 3);
                const startRamp = new THREE.Mesh(startRampGeom, rampMat);
                startRamp.position.set(0, course.hasSlope ? 1.0 : 0.1, 12.5);
                startRamp.userData.courseElement = true;
                this.scene.add(startRamp);
                
                const endRamp = new THREE.Mesh(startRampGeom, rampMat);
                endRamp.position.set(0, 0.1, -12.5);
                endRamp.userData.courseElement = true;
                this.scene.add(endRamp);
            }

            createSlopedTrack() {
                // Create a simple downward slope from start to finish
                const segments = 10;
                const startHeight = 1.5;
                const endHeight = 0.25;
                const segmentLength = 28 / segments;
                
                for (let i = 0; i < segments; i++) {
                    const progress = i / (segments - 1);
                    const height = startHeight + (endHeight - startHeight) * progress;
                    const zPos = 14 - (i * segmentLength) - (segmentLength / 2);
                    
                    const segmentGeom = new THREE.BoxGeometry(10, 0.5, segmentLength + 0.1);
                    const segmentMat = new THREE.MeshLambertMaterial({ 
                        color: new THREE.Color().setHSL(0.3, 0.7, 0.5 + progress * 0.2) // Gradient green
                    });
                    const segment = new THREE.Mesh(segmentGeom, segmentMat);
                    segment.position.set(0, height, zPos);
                    segment.userData.courseElement = true;
                    segment.receiveShadow = true;
                    this.scene.add(segment);
                }
            }

            createStripes() {
                for (let i = -3; i <= 3; i += 1.5) {
                    const stripeGeom = new THREE.PlaneGeometry(0.3, 26);
                    const stripeMat = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
                    const stripe = new THREE.Mesh(stripeGeom, stripeMat);
                    stripe.rotation.x = -Math.PI / 2;
                    stripe.position.set(i, 0.51, 0);
                    stripe.userData.courseElement = true;
                    this.scene.add(stripe);
                }
            }

            createBoundaries() {
                const boundaryMaterial = new THREE.MeshBasicMaterial({ 
                    transparent: true, 
                    opacity: 0,
                    visible: false 
                });

                const sideBoundaryGeom = new THREE.BoxGeometry(0.1, 3, 30);
                
                const leftBoundary = new THREE.Mesh(sideBoundaryGeom, boundaryMaterial);
                leftBoundary.position.set(-5.5, 1.5, 0);
                leftBoundary.userData.isBoundary = true;
                this.scene.add(leftBoundary);
                
                const rightBoundary = new THREE.Mesh(sideBoundaryGeom, boundaryMaterial);
                rightBoundary.position.set(5.5, 1.5, 0);
                rightBoundary.userData.isBoundary = true;
                this.scene.add(rightBoundary);

                const endBoundaryGeom = new THREE.BoxGeometry(11, 3, 0.1);
                
                const backBoundary = new THREE.Mesh(endBoundaryGeom, boundaryMaterial);
                backBoundary.position.set(0, 1.5, -15);
                backBoundary.userData.isBoundary = true;
                this.scene.add(backBoundary);
                
                const frontBoundary = new THREE.Mesh(endBoundaryGeom, boundaryMaterial);
                frontBoundary.position.set(0, 1.5, 15);
                frontBoundary.userData.isBoundary = true;
                this.scene.add(frontBoundary);
            }

            createBall(position) {
                const geometry = new THREE.SphereGeometry(0.4, 20, 20);
                
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0xFFFFFF,
                    shininess: 100,
                    specular: 0x222222
                });
                
                this.ball = new THREE.Mesh(geometry, material);
                this.ball.position.copy(position);
                this.ball.castShadow = true;
                this.ball.receiveShadow = true;
                this.ball.userData.courseElement = true;
                this.scene.add(this.ball);
                
                const ringGeometry = new THREE.TorusGeometry(0.6, 0.05, 8, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                this.ballRing = new THREE.Mesh(ringGeometry, ringMaterial);
                this.ballRing.position.copy(this.ball.position);
                this.ballRing.position.y = 0.7;
                this.ballRing.rotation.x = -Math.PI / 2;
                this.ballRing.userData.courseElement = true;
                this.scene.add(this.ballRing);
                
                this.ballVelocity.set(0, 0, 0);
                this.isMoving = false;
            }

            createHole(position) {
                const holeGeom = new THREE.CylinderGeometry(1.2, 1.0, 2.5, 16);
                const holeMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
                const hole = new THREE.Mesh(holeGeom, holeMat);
                hole.position.set(position.x, position.y - 1.0, position.z);
                hole.userData.courseElement = true;
                hole.userData.isHole = true;
                this.scene.add(hole);

                const innerHoleGeom = new THREE.CylinderGeometry(0.9, 0.7, 2.0, 16);
                const innerHoleMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
                const innerHole = new THREE.Mesh(innerHoleGeom, innerHoleMat);
                innerHole.position.set(position.x, position.y - 0.8, position.z);
                innerHole.userData.courseElement = true;
                this.scene.add(innerHole);

                const holeRingGeometry = new THREE.TorusGeometry(1.6, 0.08, 8, 16);
                const holeRingMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
                const holeRing = new THREE.Mesh(holeRingGeometry, holeRingMaterial);
                holeRing.position.set(position.x, 0.72, position.z);
                holeRing.rotation.x = -Math.PI / 2;
                holeRing.userData.courseElement = true;
                this.scene.add(holeRing);

                const slopeGeom = new THREE.ConeGeometry(2.8, 0.4, 16);
                const slopeMat = new THREE.MeshLambertMaterial({ 
                    color: 0x90EE90, 
                    transparent: true, 
                    opacity: 0.6 
                });
                const slope = new THREE.Mesh(slopeGeom, slopeMat);
                slope.position.set(position.x, 0.65, position.z);
                slope.rotation.x = Math.PI;
                slope.userData.courseElement = true;
                this.scene.add(slope);

                const poleGeom = new THREE.CylinderGeometry(0.05, 0.05, 8, 8);
                const poleMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const pole = new THREE.Mesh(poleGeom, poleMat);
                pole.position.set(position.x, 4.5, position.z);
                pole.userData.courseElement = true;
                this.scene.add(pole);

                const flagGeom = new THREE.PlaneGeometry(2.5, 2);
                const flagMat = new THREE.MeshLambertMaterial({ color: 0xFF0000, side: THREE.DoubleSide });
                const flag = new THREE.Mesh(flagGeom, flagMat);
                flag.position.set(position.x + 1.5, 6.8, position.z);
                flag.userData.courseElement = true;
                this.scene.add(flag);

                const markerGeom = new THREE.SphereGeometry(0.3, 8, 6);
                const markerMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
                const marker = new THREE.Mesh(markerGeom, markerMat);
                marker.position.set(position.x, 8.8, position.z);
                marker.userData.courseElement = true;
                marker.userData.isMarker = true;
                this.scene.add(marker);
            }

            createObstacles(obstacles) {
                this.obstacleBoxes = [];
                
                obstacles.forEach((obstacle) => {
                    let mesh;
                    
                    if (obstacle.type === 'wall') {
                        const geometry = new THREE.BoxGeometry(...obstacle.size);
                        const material = new THREE.MeshLambertMaterial({ color: 0xFF6B35 });
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(...obstacle.pos);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                    } else if (obstacle.type === 'block') {
                        const geometry = new THREE.BoxGeometry(...obstacle.size);
                        const material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(...obstacle.pos);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                    }
                    
                    if (mesh) {
                        mesh.userData.courseElement = true;
                        mesh.userData.isObstacle = true;
                        this.scene.add(mesh);
                        
                        this.obstacleBoxes.push({
                            box: new THREE.Box3().setFromObject(mesh),
                            mesh: mesh
                        });
                    }
                });
            }

            createTrees() {
                const positions = [
                    [-15, 0, -20], [15, 0, -20], [-15, 0, 20], [15, 0, 20],
                    [-12, 0, 0], [12, 0, 0]
                ];

                positions.forEach(pos => {
                    const group = new THREE.Group();
                    
                    const trunkGeom = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
                    const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeom, trunkMat);
                    trunk.position.y = 1.5;
                    trunk.castShadow = true;
                    group.add(trunk);

                    const leavesGeom = new THREE.SphereGeometry(2, 12, 8);
                    const leavesMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                    const leaves = new THREE.Mesh(leavesGeom, leavesMat);
                    leaves.position.y = 3.5;
                    leaves.castShadow = true;
                    group.add(leaves);

                    group.position.set(...pos);
                    group.userData.courseElement = true;
                    this.scene.add(group);
                });
            }

            setupEventListeners() {
                this.renderer.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.renderer.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.renderer.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.renderer.domElement.addEventListener('wheel', this.onWheel.bind(this));
                this.renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
                
                this.renderer.domElement.addEventListener('touchstart', this.onTouchStart.bind(this));
                this.renderer.domElement.addEventListener('touchmove', this.onTouchMove.bind(this));
                this.renderer.domElement.addEventListener('touchend', this.onTouchEnd.bind(this));
                
                document.addEventListener('keydown', this.onKeyDown.bind(this));
                document.addEventListener('keyup', this.onKeyUp.bind(this));
                
                window.addEventListener('resize', this.onWindowResize.bind(this));
            }

            adjustCamera(direction) {
                const step = 0.2; // Smaller steps for smoother control
                const zoomStep = 1.5;
                
                switch(direction) {
                    case 'left':
                        this.cameraControls.theta -= step;
                        break;
                    case 'right':
                        this.cameraControls.theta += step;
                        break;
                    case 'up':
                        this.cameraControls.phi = Math.max(0.2, this.cameraControls.phi - step * 0.5);
                        break;
                    case 'down':
                        this.cameraControls.phi = Math.min(Math.PI / 2.2, this.cameraControls.phi + step * 0.5);
                        break;
                    case 'in':
                        this.cameraControls.radius = Math.max(this.cameraControls.minRadius, this.cameraControls.radius - zoomStep);
                        break;
                    case 'out':
                        this.cameraControls.radius = Math.min(this.cameraControls.maxRadius, this.cameraControls.radius + zoomStep);
                        break;
                }
                this.updateCameraPosition();
            }

            onTouchStart(event) {
                if (event.touches.length === 1) {
                    this.onMouseDown({
                        button: 0,
                        clientX: event.touches[0].clientX,
                        clientY: event.touches[0].clientY
                    });
                }
            }

            onTouchMove(event) {
                event.preventDefault();
                if (event.touches.length === 1) {
                    this.onMouseMove({
                        clientX: event.touches[0].clientX,
                        clientY: event.touches[0].clientY
                    });
                }
            }

            onTouchEnd(event) {
                this.onMouseUp({ button: 0 });
            }

            onMouseDown(event) {
                if (event.button === 0) {
                    // Check if clicking on the ball first
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    const mouse = new THREE.Vector2(
                        ((event.clientX - rect.left) / rect.width) * 2 - 1,
                        -((event.clientY - rect.top) / rect.height) * 2 + 1
                    );

                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, this.camera);
                    const intersects = raycaster.intersectObjects([this.ball]);

                    if (intersects.length > 0) {
                        // Clicked on ball - start aiming
                        this.isAiming = true;
                        this.aimStart.set(event.clientX, event.clientY);
                        this.aimCurrent.copy(this.aimStart);
                        console.log('Clicked on ball - aiming started');
                    } else {
                        // Clicked elsewhere - no aiming
                        this.isAiming = false;
                        console.log('Clicked elsewhere - no aiming');
                    }
                }
            }

            onMouseMove(event) {
                if (this.isAiming) {
                    this.aimCurrent.set(event.clientX, event.clientY);
                    this.showAimLine();
                }
            }

            onMouseUp(event) {
                if (event.button === 0 && this.isAiming) {
                    const aimDir = new THREE.Vector2().subVectors(this.aimCurrent, this.aimStart);
                    let power = Math.min(aimDir.length() * 0.02, 2.0);
                    
                    if (power > 0.05) {
                        const worldDir = this.screenToWorldDirection(aimDir);
                        console.log(`Shooting with power: ${power}, direction:`, worldDir);
                        this.ballVelocity.copy(worldDir.multiplyScalar(power * 12));
                        this.isMoving = true;
                        this.strokes++;
                        this.updateUI();
                    }
                    
                    this.isAiming = false;
                    this.hideAimLine();
                }
            }

            screenToWorldDirection(screenDir) {
                const cameraDirection = new THREE.Vector3();
                this.camera.getWorldDirection(cameraDirection);
                cameraDirection.y = 0;
                cameraDirection.normalize();

                const cameraRight = new THREE.Vector3();
                cameraRight.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0));
                cameraRight.normalize();

                const worldDir = new THREE.Vector3();
                worldDir.addScaledVector(cameraRight, -screenDir.x * 0.001);
                worldDir.addScaledVector(cameraDirection, -screenDir.y * 0.001);
                worldDir.y = 0;
                worldDir.normalize();

                return worldDir;
            }

            onWheel(event) {
                this.cameraControls.radius = Math.max(
                    this.cameraControls.minRadius, 
                    Math.min(this.cameraControls.maxRadius, this.cameraControls.radius + event.deltaY * 0.02)
                );
                this.updateCameraPosition();
            }

            onKeyDown(event) {
                this.pressedKeys.add(event.code);
                
                if (event.code === 'ArrowLeft') {
                    event.preventDefault();
                    this.adjustCamera('left');
                } else if (event.code === 'ArrowRight') {
                    event.preventDefault();
                    this.adjustCamera('right');
                } else if (event.code === 'ArrowUp') {
                    event.preventDefault();
                    this.adjustCamera('up');
                } else if (event.code === 'ArrowDown') {
                    event.preventDefault();
                    this.adjustCamera('down');
                } else if (event.code === 'Equal' || event.code === 'NumpadAdd') {
                    event.preventDefault();
                    this.adjustCamera('in');
                } else if (event.code === 'Minus' || event.code === 'NumpadSubtract') {
                    event.preventDefault();
                    this.adjustCamera('out');
                }
                
                if (event.code === 'Space' && this.isAiming) {
                    event.preventDefault();
                    if (!this.isChargingPower) {
                        this.isChargingPower = true;
                        this.power = 0;
                        document.getElementById('powerMeter').style.display = 'block';
                        console.log('Started charging power');
                    }
                }
            }

            onKeyUp(event) {
                this.pressedKeys.delete(event.code);
                
                if (event.code === 'Space' && this.isChargingPower && this.isAiming) {
                    event.preventDefault();
                    console.log(`Releasing space with power: ${this.power}`);
                    
                    const aimDir = new THREE.Vector2().subVectors(this.aimCurrent, this.aimStart);
                    if (aimDir.length() > 5 && this.power > 0.1) {
                        const worldDir = this.screenToWorldDirection(aimDir);
                        console.log(`Shooting with charged power: ${this.power}`);
                        this.ballVelocity.copy(worldDir.multiplyScalar(this.power * 25));
                        this.isMoving = true;
                        this.strokes++;
                        this.updateUI();
                        
                        this.isAiming = false;
                        this.hideAimLine();
                    }
                    
                    this.isChargingPower = false;
                    document.getElementById('powerMeter').style.display = 'none';
                    this.power = 0;
                }
            }

            showAimLine() {
                const aimDir = new THREE.Vector2().subVectors(this.aimCurrent, this.aimStart);
                const length = Math.min(aimDir.length() * 1.0, 250);
                const power = Math.min(aimDir.length() * 0.02, 2.0);
                
                // Main aim line (thicker, colored by power)
                const indicator = document.getElementById('aimIndicator');
                indicator.style.display = 'block';
                indicator.style.left = this.aimStart.x + 'px';
                indicator.style.top = this.aimStart.y + 'px';
                indicator.style.width = length + 'px';
                indicator.style.height = Math.max(4, Math.min(10, power * 8)) + 'px';
                indicator.style.transform = `rotate(${Math.atan2(aimDir.y, aimDir.x)}rad)`;
                indicator.style.transformOrigin = '0 50%';
                
                const powerPercent = power / 2.0;
                if (powerPercent < 0.2) {
                    indicator.style.background = 'rgba(255, 255, 0, 0.9)';
                } else if (powerPercent < 0.6) {
                    indicator.style.background = 'rgba(255, 165, 0, 0.9)';
                } else {
                    indicator.style.background = 'rgba(255, 0, 0, 0.9)';
                }
                
                indicator.style.boxShadow = `0 0 ${Math.max(4, power * 10)}px ${indicator.style.background}`;
                indicator.className = 'aim-line';

                // Precision dotted line (extends further for better aiming)
                const precisionIndicator = document.getElementById('precisionAimIndicator');
                const precisionLength = Math.min(length * 2, 400); // Extends twice as far
                
                precisionIndicator.style.display = 'block';
                precisionIndicator.style.position = 'absolute';
                precisionIndicator.style.pointerEvents = 'none';
                precisionIndicator.style.left = this.aimStart.x + 'px';
                precisionIndicator.style.top = this.aimStart.y + 'px';
                precisionIndicator.style.width = precisionLength + 'px';
                precisionIndicator.style.transform = `rotate(${Math.atan2(aimDir.y, aimDir.x)}rad)`;
                precisionIndicator.style.transformOrigin = '0 50%';
                precisionIndicator.className = 'dotted-aim-line';
                precisionIndicator.style.zIndex = '49'; // Just below main aim line
            }

            hideAimLine() {
                document.getElementById('aimIndicator').style.display = 'none';
                document.getElementById('precisionAimIndicator').style.display = 'none';
            }

            checkBoundaryCollisions() {
                const ballPos = this.ball.position;
                const ballRadius = 0.4;
                
                this.boundaries.forEach(boundary => {
                    if (boundary.type === 'vertical') {
                        if (Math.abs(ballPos.x - boundary.x) < ballRadius && 
                            ballPos.z > boundary.minZ && ballPos.z < boundary.maxZ) {
                            if (ballPos.x < boundary.x) {
                                ballPos.x = boundary.x - ballRadius;
                            } else {
                                ballPos.x = boundary.x + ballRadius;
                            }
                            this.ballVelocity.x *= -0.7;
                        }
                    } else if (boundary.type === 'horizontal') {
                        if (Math.abs(ballPos.z - boundary.z) < ballRadius && 
                            ballPos.x > boundary.minX && ballPos.x < boundary.maxX) {
                            if (ballPos.z < boundary.z) {
                                ballPos.z = boundary.z - ballRadius;
                            } else {
                                ballPos.z = boundary.z + ballRadius;
                            }
                            this.ballVelocity.z *= -0.7;
                        }
                    }
                });

                this.checkObstacleCollisions();
            }

            checkObstacleCollisions() {
                const ballPos = this.ball.position;
                const ballRadius = 0.4;
                const ballSphere = new THREE.Sphere(ballPos, ballRadius);
                
                this.obstacleBoxes.forEach(obstacle => {
                    // Always update obstacle bounding box
                    obstacle.box.setFromObject(obstacle.mesh);
                    
                    if (obstacle.box.intersectsSphere(ballSphere)) {
                        console.log('Ball hit obstacle!');
                        
                        // Get obstacle bounds
                        const min = obstacle.box.min;
                        const max = obstacle.box.max;
                        
                        // Determine which face was hit
                        const ballCenter = ballPos.clone();
                        let bounceDirection = new THREE.Vector3();
                        
                        // Find closest face
                        const distToFaces = {
                            left: Math.abs(ballCenter.x - min.x),
                            right: Math.abs(ballCenter.x - max.x),
                            front: Math.abs(ballCenter.z - max.z),
                            back: Math.abs(ballCenter.z - min.z)
                        };
                        
                        const closestFace = Object.keys(distToFaces).reduce((a, b) => 
                            distToFaces[a] < distToFaces[b] ? a : b
                        );
                        
                        // Set bounce direction based on face hit
                        switch(closestFace) {
                            case 'left':
                                bounceDirection.set(-1, 0, 0);
                                ballPos.x = min.x - ballRadius - 0.1;
                                break;
                            case 'right':
                                bounceDirection.set(1, 0, 0);
                                ballPos.x = max.x + ballRadius + 0.1;
                                break;
                            case 'front':
                                bounceDirection.set(0, 0, 1);
                                ballPos.z = max.z + ballRadius + 0.1;
                                break;
                            case 'back':
                                bounceDirection.set(0, 0, -1);
                                ballPos.z = min.z - ballRadius - 0.1;
                                break;
                        }
                        
                        // Apply bounce with energy loss
                        
                        console.log(`Bounced off ${closestFace} face`);
                    }
                });
            }

            updateBallPhysics() {
                if (!this.isMoving) return;

                const deltaTime = 0.016;
                const friction = 0.98;
                const gravity = -12;

                this.ball.position.add(this.ballVelocity.clone().multiplyScalar(deltaTime));

                this.checkBoundaryCollisions();

                if (this.ballRing) {
                    this.ballRing.position.copy(this.ball.position);
                    this.ballRing.position.y = Math.max(0.7, this.ball.position.y - 0.3);
                }

                // Enhanced ground collision for slopes
                const course = this.courses[this.currentHole];
                if (course.hasSlope) {
                    // Calculate slope height at ball position
                    const progress = (14 - this.ball.position.z) / 28; // 0 at start, 1 at end
                    const clampedProgress = Math.max(0, Math.min(1, progress));
                    const startHeight = 1.5;
                    const endHeight = 0.25;
                    const slopeHeight = startHeight + (endHeight - startHeight) * clampedProgress;
                    const groundLevel = slopeHeight + 0.5; // Add platform thickness
                    
                    if (this.ball.position.y < groundLevel) {
                        this.ball.position.y = groundLevel;
                        if (this.ballVelocity.y < 0) {
                            this.ballVelocity.y *= -0.4;
                        }
                        
                        // Add slight downhill acceleration
                        if (clampedProgress < 0.95) { // Don't add speed near the hole
                            this.ballVelocity.z -= 0.5 * deltaTime; // Gravity pulls ball downhill
                        }
                    }
                } else {
                    // Standard flat ground collision
                    if (this.ball.position.y < 1.0) {
                        this.ball.position.y = 1.0;
                        if (this.ballVelocity.y < 0) {
                            this.ballVelocity.y *= -0.4;
                        }
                    }
                }

                this.ballVelocity.y += gravity * deltaTime;
                this.ballVelocity.x *= friction;
                this.ballVelocity.z *= friction;

                const speed = new THREE.Vector2(this.ballVelocity.x, this.ballVelocity.z).length();
                this.ball.rotation.x += speed * deltaTime * 2;
                this.ball.rotation.z += speed * deltaTime * 1.5;

                if (this.ballVelocity.length() < 0.15 && Math.abs(this.ball.position.y - (course.hasSlope ? this.getGroundHeight(this.ball.position.z) : 1.0)) < 0.2) {
                    this.ballVelocity.set(0, 0, 0);
                    this.ball.position.y = course.hasSlope ? this.getGroundHeight(this.ball.position.z) : 1.0;
                    this.isMoving = false;
                    console.log('Ball stopped moving');
                    this.checkHoleCompletion();
                }

                this.updateCameraPosition();
            }

            getGroundHeight(zPosition) {
                // Calculate ground height at given Z position for sloped terrain
                const progress = (14 - zPosition) / 28;
                const clampedProgress = Math.max(0, Math.min(1, progress));
                const startHeight = 1.5;
                const endHeight = 0.25;
                return startHeight + (endHeight - startHeight) * clampedProgress + 0.5;
            }

            checkHoleCompletion() {
                const holePos = this.courses[this.currentHole].holePos;
                const ballPos = this.ball.position;
                
                // Much faster and more forgiving hole detection
                const horizontalDistance = new THREE.Vector2(
                    ballPos.x - holePos.x,
                    ballPos.z - holePos.z
                ).length();
                
                // Larger detection area and higher Y threshold for faster detection
                if (horizontalDistance < 2.0 && ballPos.y < 1.5) {
                    console.log('Ball in hole! Distance:', horizontalDistance, 'Y:', ballPos.y);
                    this.sinkBallIntoHole(holePos);
                }
            }

            sinkBallIntoHole(holePos) {
                this.isMoving = false;
                this.ballVelocity.set(0, 0, 0);
                this.isAiming = false;
                this.hideAimLine();
                
                console.log('Ball sinking into hole...');
                
                const targetPos = holePos.clone();
                targetPos.y = -0.5;
                
                // Much faster sinking animation
                const sinkAnimation = () => {
                    this.ball.position.lerp(targetPos, 0.15); // Faster lerp
                    
                    if (this.ballRing) {
                        this.ballRing.position.copy(this.ball.position);
                        this.ballRing.position.y = Math.max(0.7, this.ball.position.y + 0.3);
                        this.ballRing.material.opacity = Math.max(0, (this.ball.position.y + 0.5) / 1.5);
                        this.ballRing.material.transparent = true;
                    }
                    
                    // Much smaller distance threshold for faster completion
                    if (this.ball.position.distanceTo(targetPos) > 0.3) {
                        requestAnimationFrame(sinkAnimation);
                    } else {
                        console.log('Hole completed!');
                        this.completeHole();
                    }
                };
                
                sinkAnimation();
            }

            completeHole() {
                this.totalScore += this.strokes;
                
                if (this.currentHole < this.totalHoles) {
                    setTimeout(() => {
                        this.currentHole++;
                        this.strokes = 0;
                        this.loadHole(this.currentHole);
                        this.updateUI();
                    }, 1500);
                } else {
                    this.endGame();
                }
            }

            async endGame() {
                document.getElementById('finalScore').textContent = this.totalScore;
                
                // Check if this is a new best score
                const currentBestText = document.getElementById('bestScore').textContent;
                const currentBest = currentBestText === '--' ? null : parseInt(currentBestText);
                const isNewBest = !currentBest || this.totalScore < currentBest;
                const isPersonalBest = !isGuest && isNewBest;
                
                let scoreMessage = '';
                if (isGuest) {
                    scoreMessage = '<p style="color: #ffa500;">Sign up to save your scores!</p>';
                } else if (isPersonalBest) {
                    scoreMessage = '<p style="color: #4CAF50; font-weight: bold;">üéâ New Personal Best! üéâ</p>';
                    // Update best score display
                    document.getElementById('bestScore').textContent = this.totalScore;
                    // Save to database
                    await saveBestScore(this.totalScore);
                } else if (currentBest) {
                    const difference = this.totalScore - currentBest;
                    scoreMessage = `<p style="color: #ccc;">Best: ${currentBest} (${difference > 0 ? '+' + difference : difference} strokes)</p>`;
                }
                
                document.getElementById('scoreComparison').innerHTML = scoreMessage;
                document.getElementById('gameComplete').style.display = 'block';
                
                // Refresh leaderboard
                loadLeaderboard();
            }

            updateUI() {
                document.getElementById('holeNumber').textContent = this.currentHole;
                document.getElementById('par').textContent = this.courses[this.currentHole].par;
                document.getElementById('strokes').textContent = this.strokes;
                document.getElementById('totalScore').textContent = this.totalScore;
                
                if (this.isChargingPower) {
                    const percentage = (this.power / this.maxPower) * 100;
                    document.getElementById('powerFill').style.height = percentage + '%';
                }
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));

                // More controlled camera movement
                if (this.pressedKeys.has('ArrowLeft')) {
                    this.adjustCamera('left');
                } else if (this.pressedKeys.has('ArrowRight')) {
                    this.adjustCamera('right');
                } else if (this.pressedKeys.has('ArrowUp')) {
                    this.adjustCamera('up');
                } else if (this.pressedKeys.has('ArrowDown')) {
                    this.adjustCamera('down');
                } else if (this.pressedKeys.has('Equal') || this.pressedKeys.has('NumpadAdd')) {
                    this.adjustCamera('in');
                } else if (this.pressedKeys.has('Minus') || this.pressedKeys.has('NumpadSubtract')) {
                    this.adjustCamera('out');
                }

                if (this.isChargingPower) {
                    this.power = Math.min(this.power + this.powerChargeSpeed * 0.016, this.maxPower);
                    this.updateUI();
                }

                // Smooth blinking markers
                this.scene.traverse((child) => {
                    if (child.userData.isMarker) {
                        const time = Date.now() * 0.002;
                        child.material.opacity = 0.6 + 0.4 * Math.sin(time);
                        child.material.transparent = true;
                    }
                });

                this.updateBallPhysics();
                this.renderer.render(this.scene, this.camera);
            }
        }

        function restartGame() {
            document.getElementById('gameComplete').style.display = 'none';
            window.game.currentHole = 1;
            window.game.strokes = 0;
            window.game.totalScore = 0;
            window.game.loadHole(window.game.currentHole);
            window.game.updateUI();
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            if (DEMO_MODE) {
                // In demo mode, show auth panel immediately
                showAuthScreen();
            } else if (supabase) {
                // Check if user is already signed in
                supabase.auth.getSession().then(({ data: { session } }) => {
                    if (session) {
                        currentUser = session.user;
                        isGuest = false;
                        startGame();
                    } else {
                        showAuthScreen();
                    }
                });
            } else {
                // Fallback to demo mode if Supabase isn't configured
                showAuthScreen();
            }
        });
    </script>
</body>
</html>
